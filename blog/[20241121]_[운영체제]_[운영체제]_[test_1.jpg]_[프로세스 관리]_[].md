# 프로세스의 관리

#### 프로세스의 개념

1. 프로세스의 문맥
   - CPU 수행 상태를 나타내는 하드웨어 문맥
     - Program Counter
     - 각종 register
   - 프로세스의 주소 공간
     - code. data, sack
   - 프로세스 관련 커널 자료구조
     - PCB(Process Conterl Block)
     - Kernel stack

---

#### 프로세스의 상태

- 프로세스는 상태가 변경되며 수행

  - Running → CPU를 잡고 기능을 수행중인 상태
  - Ready → CPU를 기다리는 상태
  - Blocked → CPU를 주어도 당장 기능을 수행할수 없는 상태
  - Suspeneded
    - 외부적인 이유(메모지 부족등) 프로세스의 수행이 정지된 상태

  그럼 Blocked 와 Suspeneded 의 차이는 멀까?

  공통적인 부분은 프로세스의 상태가 정지된 것은 맞다 다만

  Blocked는 자신이 요청한 event가 만족되면 Ready
  Suspeneded는 외부에서 다시 실행해 주어야 활성화된다.

프로세스 상태도

- 프로세스가 CPU 점유를 내어주는 이유는 3가지가 있다.
  - Timer 인터럽트로 인해 시간을 다 소비하여 다음 대기열로 이동되는 상황
  - 시간이 오래걸리는 I/O를 요청해서 다음 대기열로 이동
  - 작업이 끝나서 종료되는 상

---

#### PCB

- 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보
- 구성요소
  - OS가 관리상 사용하는 정보
    - Process state, Process ID
    - scheduling informatiom. priority
  - CPU 수행 관련 하드웨어 값
    - Program counter, registers
  - 메모리 관련
    - Code, data, stack의 위치 정보
  - 파일 관련
    - Open file descriptors

---

#### 문맥 교환

- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
- CPU가 다른 프로세스에게 넘어갈 때 운영체제는 하위 과정을 수행
  - CPU를 내어주는 프로세스의 상태를 그 포로세의 PCB에 저장
  - CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴

CPU 입장에서는 프로세스를 빠르게 처리하면서 로테이션을 돌리건데 그 중간 과정을 저장할 위치가 필요하다 그 역할을 하는 것이 PCB 이다 즉 A의 PCB는 현재 여기까지 작업을 했다. B의 PCB도 여기 까지 작업을 했으니 다음 차례가 왔을때 저장된 상태부터 다시 작업을 이어 나가는 흐름

---

#### 스케줄러

- 장기 스케쥴러

  - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
  - 프로세스에 memory(각종 자원)을 주는 문제
  - time sharing sysytem에는 보통 장기 스케줄러가 없음(무조건 ready)

- 단기 스케쥴러

  - 어떤 프로세스를 다음번에 running 시킬지 결정
  - 프로세스에 CPU를 주는 문제

- 중기 스케줄러
  - 여유 공간 마련을 위해(무조건 다 실행순서에 집어넣기 때문에) 통쨰로 메모리에서 디스크로 쫓아냄
  - 프로세스에게서 memory를 뺏는 문제

---

#### 프로세스 상태도

![alt text](./img/image.png)

---

#### 쓰레드

쓰레드를 알기 전에 잠시 프로세스에 대해 생각해 보자

예를들어 네이버 창을 여러개를 사용하고 있으면 여러 프로세스가 실행이 되고 있는건데 그렇게 되면 각각의 주소공간과 PCB가 만들어질 텐데

분명 공통적인것이 실행될 것이다. 물론 똑같은 페이지를 보고 있는것은

아니지만 이걸 더 효율적으로 실행 할 방법이 없을까?

주소 공간에 쓰레드 1의 스택 2의 스택 이렇게 분류하고

PCB의 포인터는 같은 주소를 공유하고 있을테니 실질적인 다른 창을 보여주는 코드 부분에만 1번 쓰레드는 메인화면을 보여줘

2번쓰레드는 뉴스기사를 보여줘 라고 실행하면 더 효율적이다.

- thread는 CPU 활용의 기본 단위

- thread의 구성 요소

  - 프로그램 카운터
  - 레지스터 집합
  - 스택 공간

- Thread가 다른 thread와 공유하는 부분(=태스크)

  - 코드 섹션
  - 데이터 섹션
  - 운영체제 자원

- 쓰레드의 장점

  - 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리 가능

    - 예를들어 뉴스 글을 불러올떄 이미지는 불러오는 속도가 느린데 다른 스레드가 뉴스 글이라도 빨리 보여주면서 사용자 입장에서 응답이 빠르다고 느낄수 있다.

  - 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을수 있다.

  - 스레드를 사용하면 병렬성을 높일수 있다.

---

#### 프로세스 셍성

- 부모 프로세스가 자식 프로세스 생성
- 프로세스의 트리구조 형성
- 프로세스는 자원을 필요로 함
  - 운영체제로부터 받는다
  - 부모와 공유
- 자원 공유
  - 부모와 자식이 모든 자원을 공유하는 모델
  - 일부를 공유하는 모델
  - 전혀 공유하지 않는 모델
- 수행
  - 부모와 자식은 공존하며 수행되는 모델
  - 자식이 종료될때까지 부모가 기다리는 모델

자식 프로세스 생성

- 주소 공간
  - 자식은 부모의 공간을 복사함
  - 자식은 그 공간에 새로운 프로그램을 올림

프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit)
  - 자식이 부모에게 output data를 보냄(via wait)
  - 프로세스의 각종 자원들이 운영체제에게 반납됨
- 부모 프로세스가 자식의 수행을 종료시킴(abort)
  - 자식이 할당 자원의 한계치를 넘어섬
  - 자식에게 할당된 태스크가 더 이상 필요하지 않음
  - 부모가 죵로하는 경우
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되지않도록 제어
    - 단계적인 종료 -> 계층구조란걸 명심
