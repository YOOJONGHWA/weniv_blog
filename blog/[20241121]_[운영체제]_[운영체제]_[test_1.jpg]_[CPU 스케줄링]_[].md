# CPU 스케줄링

---

#### CPU 스케줄링 & 디스패쳐

- **CPU 스케줄링**

  - Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.

- **디스패쳐**

  - CPU의 제어권을 CPU 스케줄러에 의해 선택된 프로세스에게 넘긴다.
  - 이 과정을 context switch(문맥 교환)이라 한다.

- **CPU 스케줄링이 필요한 경우**

  - Running -> Blocked (ex: I/O 요청하는 시스템 콜)
  - Running -> Ready (ex: 할당시간 만료로 인한 time interrupt)
  - Blocked -> Ready (ex: I/O 완료 후 인터럽트)
  - Terminate

---

#### 스케쥴링 성능 척도

- **CPU 이용률** -> 이용률이 높을수록 좋다.
- **처리량** -> 높을수록 좋다.
- **소요 시간**
- **대기 시간**
- **응답 시간**

---

#### 스케쥴링 알고리즘

1. **FCFS(First-Come First-Served)**

   - 가장 먼저 도착한 프로세스 별로 실행시키는 알고리즘

   | Process | Burst Time |
   | ------- | ---------- |
   | P1      | 24         |
   | P2      | 3          |
   | P3      | 3          |

   - 프로세스의 도착 순서: P1, P2, P3
   - 응답 시간 -> P1 = 0, P2 = 24, P3 = 27
   - 평균 응답 시간 -> (0 + 24 + 27) / 3 = 17

2. **SJF (Shortest-Job-First)**

   - 각 프로세스의 다음번 CPU burst time을 가지고 스케줄링에 활용
   - CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케쥴링
   - **2가지 버전 존재**:

     - **비선점**
       - 일단 CPU를 잡으면 이번 CPU burst가 완료될 때까지 CPU를 선점당하지 않음.
     - **선점**
       - 현재 수행 중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗김.

   - 다른 어떤 알고리즘을 쓰더라도 SJF보다 평균 대기 시간을 가장 낮게 가져가는 것을 보장받을 수 있다. (선점 방식 포함)

   **비선점 방식 예시**

   | Process | Arrival Time | Burst Time |
   | ------- | ------------ | ---------- |
   | P1      | 0            | 7          |
   | P2      | 2            | 4          |
   | P3      | 4            | 1          |
   | P4      | 5            | 4          |

   | Process | Arrival Time | Burst Time | Completion Time | Waiting Time |
   | ------- | ------------ | ---------- | --------------- | ------------ |
   | P1      | 0            | 7          | 7               | 0            |
   | P3      | 4            | 1          | 8               | 3 (7 - 4)    |
   | P2      | 2            | 4          | 12              | 6 (8 - 2)    |
   | P4      | 5            | 4          | 16              | 7 (12 - 4)   |

   - 평균 대기 시간 = (0 + 6 + 3 + 7) / 4 = 4

   **선점 방식 예시**

   | Process | Arrival Time | Burst Time | Completion Time | Waiting Time   |
   | ------- | ------------ | ---------- | --------------- | -------------- |
   | P1      | 0            | 7          | 16              | 9 (16 - 7 - 0) |
   | P2      | 2            | 4          | 8               | 2 (8 - 4 - 2)  |
   | P3      | 4            | 1          | 5               | 0 (5 - 1 - 4)  |
   | P4      | 5            | 4          | 12              | 3 (12 - 4 - 5) |

   - 평균 대기 시간 = (9 + 2 + 0 + 3) / 4 = 3

   - **문제점** -> 실행 시간이 긴 프로세스는 결국 한 번도 실행되지 않을 수도 있음.

3. **Priority Scheduling**

   - 가장 높은 우선순위를 가진 프로세스에게 CPU 할당
   - **비선점**과 **선점** 모두 존재
   - **문제점** -> 낮은 우선순위 프로세스는 한 번도 실행되지 않을 수도 있음.
   - **해결법** -> **Aging**: 나이가 든 프로세스는 우선순위를 높여서 실행하게 함.

4. **Round Robin**

   - 각 프로세스는 동일한 크기의 할당 시간을 가짐
   - 할당 시간이 지나면 프로세스는 선점당하고 Ready Queue의 제일 뒤에 가서 다시 줄을 섬.
   - 일반적으로 SJF보다 평균 turnaround 시간이 길지만 응답 시간은 더 짧음.

5. **Multilevel Queue**

   - 프로세스를 우선순위별로 여러 개의 큐에 나누어 관리하는 스케줄링 알고리즘
   - 각 큐는 고유한 우선순위를 가지며, 프로세스는 할당된 큐 내에서만 처리
   - 높은 우선순위 큐는 실시간 작업을, 낮은 우선순위 큐는 백그라운드 작업 처리
   - 큐 간에 프로세스 이동은 없음.
   - 각 큐에는 다른 스케줄링 알고리즘을 적용 가능

---

#### 알고리즘 평가 방법

1. **Queueing Models**

   - 확률 분포로 주어지는 도착 시간과 처리율 등을 통해 각종 성능 지표 값을 계산.

2. **구현 및 성능 측정**

   - 실제 시스템에 알고리즘을 구현하여 실제 작업에 대해 성능을 측정, 비교.

3. **모의실험**

   - 알고리즘을 모의 프로그램으로 작성한 후 trace를 입력하여 결과 비교.
